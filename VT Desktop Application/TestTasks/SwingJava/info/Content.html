<h1 style="color: #f0fff0; text-align: center;">Изучаемые классы</h1>
<h3 style="color: #f0fff0;">Основным изучаемым классом станет <span style="text-decoration: underline;">CountDownLatch</span>. Для его создания используется следующий конструктор:</h3>
<h3 style="color: #7FFFD4;">new CountDownLatch (int count) </h3>
<h3 style="color: #f0fff0;">count здесь - это количество условий, которые должны быть выполнены перед тем, как все потоки освободятся</h3>
<h4 style="color: #f0fff0;">P.s. количество условий в нашем примере будет стоять на пяти по условию</h4>
<h3 style="color: #f0fff0;">Для того, чтобы поток остался ждать на нашем замке с обратным отсчётом, нужно воспользоваться следующим методом:</h3>
<h3 style="color: #7FFFD4;">countDownLatch.await()</h3>
<h3 style="color: #f0fff0;">После этого поток будет ждать, пока не выполнятся все условия.</h3>
<h3 style="color: #f0fff0;">Чтобы уведомить замок о том, что выполнено очередное условие, воспользуйтесь методом</h3>
<h3 style="color: #7FFFD4;">countDownLatch.countDown()</h3>
<h3 style="color: #f0fff0;">Как только внутренний счётчик достигнет нуля, все ожидающие потоки разблокируются и начнут выполнять свою работу!</h3>
<br><br>
<h3 style="color: #f0fff0;">Также вам понадобится следующий метод остановки потока выполнения (чтобы, например, отсчёт до начала гонки происходил не мгновенно</h3>
<h3 style="color: #7FFFD4;">Thread.sleep(long millis)</h3>